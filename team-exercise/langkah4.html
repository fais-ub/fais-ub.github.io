<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Textured Room – Final (non-module v0.146.0)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#111; }
    canvas { display:block; }
    .hint {
      position:absolute; top:10px; left:50%; transform:translateX(-50%);
      color:#ddd; font-family:system-ui, sans-serif; font-size:14px; text-align:center;
      background:rgba(0,0,0,.35); padding:6px 10px; border-radius:8px; user-select:none;
    }
  </style>
</head>
<body>
<div class="hint">Drag = rotate · Scroll = zoom · Right-drag = pan · R = reset camera</div>

<!-- Three core (non-module, kompatibel OrbitControls global) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<!-- OrbitControls non-module -->
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

<script>
  // ========= 1) Scene, Camera, Renderer =========
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
  const defaultPos = new THREE.Vector3(0, 1.5, 2.0);     // berada di dalam ruangan
  camera.position.copy(defaultPos);
  camera.lookAt(0, 1, 0);                                 // fokus ke tengah ruangan (tinggi ~mata)

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // ========= 2) Controls =========
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 1, 0);

  // ========= 3) Lights =========
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  const point   = new THREE.PointLight(0xffffff, 1.0, 100);
  point.position.set(0, 2.4, 0); // lampu dekat atap, pusat ruangan
  scene.add(ambient, point);

  // ========= 4) Texture loader + fallback =========
  const loader = new THREE.TextureLoader();

  function makeFallback(label) {
    const c = document.createElement('canvas'); c.width = c.height = 256;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0,0,256,256);
    ctx.fillStyle = '#999'; ctx.font = '16px system-ui'; ctx.fillText(label, 20, 130);
    return new THREE.CanvasTexture(c);
  }

  function safeLoad(path, label) {
    let tex = loader.load(
      path,
      () => { tex.needsUpdate = true; },
      undefined,
      () => { tex = makeFallback(label); }
    );
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    return tex;
  }

  // Ganti dengan file Anda (opsional); jika tidak ada, fallback akan tampil
  const floorTex   = safeLoad('floor.jpg',   'floor.jpg?');
  const wallTex    = safeLoad('wall.jpg',    'wall.jpg?');
  const ceilingTex = safeLoad('ceiling.jpg', 'ceiling.jpg?');

  // Tiling bawaan
  floorTex.repeat.set(2, 2);
  wallTex.repeat.set(1.5, 1);
  ceilingTex.repeat.set(1, 1);

  // ========= 5) Materials – FrontSide (menghadap interior) =========
  const matFloor   = new THREE.MeshStandardMaterial({ map: floorTex,   side: THREE.FrontSide });
  const matWall    = new THREE.MeshStandardMaterial({ map: wallTex,    side: THREE.FrontSide });
  const matCeiling = new THREE.MeshStandardMaterial({ map: ceilingTex, side: THREE.FrontSide });

  // ========= 6) Room Geometry (dilihat dari dalam) =========
  // Ukuran ruangan
  const W = 4;   // lebar  X
  const H = 3;   // tinggi Y
  const D = 6;   // panjang Z

  // LANTAI: normal +Y (rotasi -90° X)
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
  floor.rotation.x = -Math.PI / 2;
  floor.position.set(0, 0, 0);
  scene.add(floor);

  // ATAP: normal -Y (rotasi +90° X)
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matCeiling);
  ceiling.rotation.x =  Math.PI / 2;
  ceiling.position.set(0, H, 0);
  scene.add(ceiling);

  // DINDING BELAKANG (z = -D/2): sisi interior menghadap +Z → TANPA rotasi
  const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
  backWall.position.set(0, H/2, -D/2);
  scene.add(backWall);

  // DINDING DEPAN (z = +D/2): sisi interior menghadap -Z → rotasi 180° Y
  const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
  frontWall.rotation.y = Math.PI;
  frontWall.position.set(0, H/2,  D/2);
  scene.add(frontWall);

  // DINDING KIRI  (x = -W/2): sisi interior menghadap +X → rotasi -90° Y
  const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
  leftWall.rotation.y = -Math.PI / 2;
  leftWall.position.set(-W/2, H/2, 0);
  scene.add(leftWall);

  // DINDING KANAN (x = +W/2): sisi interior menghadap -X → rotasi +90° Y
  const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
  rightWall.rotation.y =  Math.PI / 2;
  rightWall.position.set( W/2, H/2, 0);
  scene.add(rightWall);

  // ========= 7) Loop =========
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // ========= 8) Resize & Reset =========
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      camera.position.copy(defaultPos);
      controls.target.set(0, 1, 0);
      camera.lookAt(0, 1, 0);
      controls.update();
    }
  });
</script>
</body>
</html>
